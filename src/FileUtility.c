/* FileUtility.c generated by valac 0.14.2, the Vala compiler
 * generated from FileUtility.vala, do not modify */

/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* PSNotes
 *
 * Copyright (C) Zach Burnham 2012 <thejambi@gmail.com>
 *
PSNotes is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * PSNotes is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * Get the file path with the unique timestamp inserted at end of 
 * filename before file extension.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>


#define TYPE_FILE_UTILITY (file_utility_get_type ())
#define FILE_UTILITY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FILE_UTILITY, FileUtility))
#define FILE_UTILITY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FILE_UTILITY, FileUtilityClass))
#define IS_FILE_UTILITY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FILE_UTILITY))
#define IS_FILE_UTILITY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FILE_UTILITY))
#define FILE_UTILITY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FILE_UTILITY, FileUtilityClass))

typedef struct _FileUtility FileUtility;
typedef struct _FileUtilityClass FileUtilityClass;
typedef struct _FileUtilityPrivate FileUtilityPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _FileUtility {
	GObject parent_instance;
	FileUtilityPrivate * priv;
};

struct _FileUtilityClass {
	GObjectClass parent_class;
};


static gpointer file_utility_parent_class = NULL;

GType file_utility_get_type (void) G_GNUC_CONST;
enum  {
	FILE_UTILITY_DUMMY_PROPERTY
};
void file_utility_createFolder (const gchar* dirPath);
gchar* file_utility_getFileExtension (GFileInfo* file);
gchar* file_utility_getFileNameWithoutExtension (GFileInfo* file);
gchar* file_utility_pathCombine (const gchar* pathStart, const gchar* pathEnd);
FileUtility* file_utility_new (void);
FileUtility* file_utility_construct (GType object_type);


/**
 * Create a folder (or make sure it exists).
 */
void file_utility_createFolder (const gchar* dirPath) {
	const gchar* _tmp0_;
	g_return_if_fail (dirPath != NULL);
	_tmp0_ = dirPath;
	g_mkdir_with_parents (_tmp0_, 0775);
}


/**
 * Return the file extension from the given fileInfo.
 */
static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _result_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


gchar* file_utility_getFileExtension (GFileInfo* file) {
	gchar* result = NULL;
	GFileInfo* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* fileName;
	gint _tmp3_ = 0;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp0_ = file;
	_tmp1_ = g_file_info_get_name (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	fileName = _tmp2_;
	_tmp3_ = string_last_index_of (fileName, ".", 0);
	_tmp4_ = string_substring (fileName, (glong) _tmp3_, (glong) (-1));
	result = _tmp4_;
	_g_free0 (fileName);
	return result;
}


/**
 * 
 */
static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		GRegex* _tmp3_;
		GRegex* _tmp4_;
		GRegex* regex;
		GRegex* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch2_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = regex;
		_tmp6_ = replacement;
		_tmp7_ = g_regex_replace_literal (_tmp5_, self, (gssize) (-1), 0, _tmp6_, 0, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch2_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp8_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally2;
	__catch2_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


gchar* file_utility_getFileNameWithoutExtension (GFileInfo* file) {
	gchar* result = NULL;
	GFileInfo* _tmp0_;
	const gchar* _tmp1_ = NULL;
	GFileInfo* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp0_ = file;
	_tmp1_ = g_file_info_get_name (_tmp0_);
	_tmp2_ = file;
	_tmp3_ = file_utility_getFileExtension (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = string_replace (_tmp1_, _tmp4_, "");
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	result = _tmp6_;
	return result;
}


/**
 * Return correctly combined path.
 */
gchar* file_utility_pathCombine (const gchar* pathStart, const gchar* pathEnd) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	g_return_val_if_fail (pathStart != NULL, NULL);
	g_return_val_if_fail (pathEnd != NULL, NULL);
	_tmp0_ = pathStart;
	_tmp1_ = pathEnd;
	_tmp2_ = g_build_path (G_DIR_SEPARATOR_S, _tmp0_, _tmp1_, NULL);
	result = _tmp2_;
	return result;
}


FileUtility* file_utility_construct (GType object_type) {
	FileUtility * self = NULL;
	self = (FileUtility*) g_object_new (object_type, NULL);
	return self;
}


FileUtility* file_utility_new (void) {
	return file_utility_construct (TYPE_FILE_UTILITY);
}


static void file_utility_class_init (FileUtilityClass * klass) {
	file_utility_parent_class = g_type_class_peek_parent (klass);
}


static void file_utility_instance_init (FileUtility * self) {
}


/**
 * File Utility class.
 */
GType file_utility_get_type (void) {
	static volatile gsize file_utility_type_id__volatile = 0;
	if (g_once_init_enter (&file_utility_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FileUtilityClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) file_utility_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FileUtility), 0, (GInstanceInitFunc) file_utility_instance_init, NULL };
		GType file_utility_type_id;
		file_utility_type_id = g_type_register_static (G_TYPE_OBJECT, "FileUtility", &g_define_type_info, 0);
		g_once_init_leave (&file_utility_type_id__volatile, file_utility_type_id);
	}
	return file_utility_type_id__volatile;
}



