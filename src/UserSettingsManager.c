/* UserSettingsManager.c generated by valac 0.14.2, the Vala compiler
 * generated from UserSettingsManager.vala, do not modify */

/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* PSNotes
 *
 * Copyright (C) Zach Burnham 2012 <thejambi@gmail.com>
 *
PSNotes is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * PSNotes is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <glib/gstdio.h>


#define TYPE_USER_SETTINGS_MANAGER (user_settings_manager_get_type ())
#define USER_SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_SETTINGS_MANAGER, UserSettingsManager))
#define USER_SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_USER_SETTINGS_MANAGER, UserSettingsManagerClass))
#define IS_USER_SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_SETTINGS_MANAGER))
#define IS_USER_SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_USER_SETTINGS_MANAGER))
#define USER_SETTINGS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_SETTINGS_MANAGER, UserSettingsManagerClass))

typedef struct _UserSettingsManager UserSettingsManager;
typedef struct _UserSettingsManagerClass UserSettingsManagerClass;
typedef struct _UserSettingsManagerPrivate UserSettingsManagerPrivate;
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _UserSettingsManager {
	GObject parent_instance;
	UserSettingsManagerPrivate * priv;
};

struct _UserSettingsManagerClass {
	GObjectClass parent_class;
};

struct _UserSettingsManagerPrivate {
	GKeyFile* keyFile;
	gchar* psNotesConfPath;
};


static gpointer user_settings_manager_parent_class = NULL;

GType user_settings_manager_get_type (void) G_GNUC_CONST;
#define USER_SETTINGS_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_USER_SETTINGS_MANAGER, UserSettingsManagerPrivate))
enum  {
	USER_SETTINGS_MANAGER_DUMMY_PROPERTY
};
#define USER_SETTINGS_MANAGER_notesDirKey "notesDirectory"
#define USER_SETTINGS_MANAGER_notesDirGroup "PSNotes"
UserSettingsManager* user_settings_manager_new (void);
UserSettingsManager* user_settings_manager_construct (GType object_type);
const gchar* user_data_get_homeDirPath (void);
void file_utility_createFolder (const gchar* dirPath);
static gboolean user_settings_manager_processKeyFile (UserSettingsManager* self);
static void user_settings_manager_writeKeyFile (UserSettingsManager* self);
const gchar* user_data_get_notesDirPath (void);
void user_data_set_notesDirPath (const gchar* value);
void zystem_debug (const gchar* s);
gchar* user_data_getDefaultNotesDir (void);
void user_settings_manager_setNotesDir (UserSettingsManager* self, const gchar* path);
static void user_settings_manager_finalize (GObject* obj);


UserSettingsManager* user_settings_manager_construct (GType object_type) {
	UserSettingsManager * self = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* settingsDirPath;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	GFile* _tmp7_ = NULL;
	GFile* settingsFile;
	GFile* _tmp8_;
	gboolean _tmp9_ = FALSE;
	GKeyFile* _tmp16_;
	gboolean _tmp22_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (UserSettingsManager*) g_object_new (object_type, NULL);
	_tmp0_ = user_data_get_homeDirPath ();
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strconcat (_tmp1_, "/.config/psnotes", NULL);
	settingsDirPath = _tmp2_;
	_tmp3_ = settingsDirPath;
	file_utility_createFolder (_tmp3_);
	_tmp4_ = settingsDirPath;
	_tmp5_ = g_strconcat (_tmp4_, "/psnotes.conf", NULL);
	_g_free0 (self->priv->psNotesConfPath);
	self->priv->psNotesConfPath = _tmp5_;
	_tmp6_ = self->priv->psNotesConfPath;
	_tmp7_ = g_file_new_for_path (_tmp6_);
	settingsFile = _tmp7_;
	_tmp8_ = settingsFile;
	_tmp9_ = g_file_query_exists (_tmp8_, NULL);
	if (!_tmp9_) {
		{
			GFile* _tmp10_;
			GFileOutputStream* _tmp11_ = NULL;
			GFileOutputStream* _tmp12_;
			_tmp10_ = settingsFile;
			_tmp11_ = g_file_create (_tmp10_, G_FILE_CREATE_NONE, NULL, &_inner_error_);
			_tmp12_ = _tmp11_;
			_g_object_unref0 (_tmp12_);
			if (_inner_error_ != NULL) {
				goto __catch5_g_error;
			}
		}
		goto __finally5;
		__catch5_g_error:
		{
			GError* e = NULL;
			FILE* _tmp13_;
			GError* _tmp14_;
			const gchar* _tmp15_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp13_ = stderr;
			_tmp14_ = e;
			_tmp15_ = _tmp14_->message;
			fprintf (_tmp13_, "Error creating settings file: %s\n", _tmp15_);
			_g_error_free0 (e);
		}
		__finally5:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (settingsFile);
			_g_free0 (settingsDirPath);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp16_ = g_key_file_new ();
	_g_key_file_free0 (self->priv->keyFile);
	self->priv->keyFile = _tmp16_;
	{
		GKeyFile* _tmp17_;
		const gchar* _tmp18_;
		_tmp17_ = self->priv->keyFile;
		_tmp18_ = self->priv->psNotesConfPath;
		g_key_file_load_from_file (_tmp17_, _tmp18_, 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch6_g_error;
		}
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		FILE* _tmp19_;
		GError* _tmp20_;
		const gchar* _tmp21_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp19_ = stderr;
		_tmp20_ = e;
		_tmp21_ = _tmp20_->message;
		fprintf (_tmp19_, "Error in UserSettingsManager(): %s\n", _tmp21_);
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (settingsFile);
		_g_free0 (settingsDirPath);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp22_ = user_settings_manager_processKeyFile (self);
	if (_tmp22_) {
		user_settings_manager_writeKeyFile (self);
	}
	_g_object_unref0 (settingsFile);
	_g_free0 (settingsDirPath);
	return self;
}


UserSettingsManager* user_settings_manager_new (void) {
	return user_settings_manager_construct (TYPE_USER_SETTINGS_MANAGER);
}


/**
 * Process the key file. Return true if keyFile needs to be written.
 */
static gboolean user_settings_manager_processKeyFile (UserSettingsManager* self) {
	gboolean result = FALSE;
	GKeyFile* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* originalKeyFileData;
	GKeyFile* _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gboolean _tmp15_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->keyFile;
	_tmp1_ = g_key_file_to_data (_tmp0_, NULL, NULL);
	originalKeyFileData = _tmp1_;
	{
		GKeyFile* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		_tmp2_ = self->priv->keyFile;
		_tmp3_ = g_key_file_get_string (_tmp2_, USER_SETTINGS_MANAGER_notesDirGroup, USER_SETTINGS_MANAGER_notesDirKey, &_inner_error_);
		_tmp4_ = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch7_g_key_file_error;
			}
			_g_free0 (originalKeyFileData);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_tmp5_ = user_data_get_notesDirPath ();
		_tmp6_ = _tmp5_;
		_tmp7_ = _tmp4_;
		user_data_set_notesDirPath (_tmp7_);
		_g_free0 (_tmp7_);
		zystem_debug ("Got notes dir path");
	}
	goto __finally7;
	__catch7_g_key_file_error:
	{
		GError* e = NULL;
		const gchar* _tmp8_;
		const gchar* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = user_data_get_notesDirPath ();
		_tmp9_ = _tmp8_;
		_tmp10_ = user_data_getDefaultNotesDir ();
		_tmp11_ = _tmp10_;
		user_data_set_notesDirPath (_tmp11_);
		_g_free0 (_tmp11_);
		zystem_debug ("Gotta use the default...");
		_g_error_free0 (e);
	}
	__finally7:
	if (_inner_error_ != NULL) {
		_g_free0 (originalKeyFileData);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp12_ = self->priv->keyFile;
	_tmp13_ = g_key_file_to_data (_tmp12_, NULL, NULL);
	_tmp14_ = _tmp13_;
	_tmp15_ = g_strcmp0 (originalKeyFileData, _tmp14_) != 0;
	_g_free0 (_tmp14_);
	result = _tmp15_;
	_g_free0 (originalKeyFileData);
	return result;
}


/**
 * Write settings file.
 */
static void user_settings_manager_writeKeyFile (UserSettingsManager* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		const gchar* _tmp0_;
		GKeyFile* _tmp1_;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		_tmp0_ = self->priv->psNotesConfPath;
		_tmp1_ = self->priv->keyFile;
		_tmp2_ = g_key_file_to_data (_tmp1_, NULL, NULL);
		_tmp3_ = _tmp2_;
		g_file_set_contents (_tmp0_, _tmp3_, (gssize) (-1), &_inner_error_);
		_g_free0 (_tmp3_);
		if (_inner_error_ != NULL) {
			goto __catch8_g_error;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		FILE* _tmp4_;
		GError* _tmp5_;
		const gchar* _tmp6_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = stderr;
		_tmp5_ = e;
		_tmp6_ = _tmp5_->message;
		fprintf (_tmp4_, "Error writing keyFile: %s\n", _tmp6_);
		_g_error_free0 (e);
	}
	__finally8:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void user_settings_manager_setNotesDir (UserSettingsManager* self, const gchar* path) {
	GKeyFile* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = self->priv->keyFile;
	_tmp1_ = path;
	g_key_file_set_string (_tmp0_, USER_SETTINGS_MANAGER_notesDirGroup, USER_SETTINGS_MANAGER_notesDirKey, _tmp1_);
	user_settings_manager_writeKeyFile (self);
}


static void user_settings_manager_class_init (UserSettingsManagerClass * klass) {
	user_settings_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UserSettingsManagerPrivate));
	G_OBJECT_CLASS (klass)->finalize = user_settings_manager_finalize;
}


static void user_settings_manager_instance_init (UserSettingsManager * self) {
	self->priv = USER_SETTINGS_MANAGER_GET_PRIVATE (self);
}


static void user_settings_manager_finalize (GObject* obj) {
	UserSettingsManager * self;
	self = USER_SETTINGS_MANAGER (obj);
	_g_key_file_free0 (self->priv->keyFile);
	_g_free0 (self->priv->psNotesConfPath);
	G_OBJECT_CLASS (user_settings_manager_parent_class)->finalize (obj);
}


GType user_settings_manager_get_type (void) {
	static volatile gsize user_settings_manager_type_id__volatile = 0;
	if (g_once_init_enter (&user_settings_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UserSettingsManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) user_settings_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UserSettingsManager), 0, (GInstanceInitFunc) user_settings_manager_instance_init, NULL };
		GType user_settings_manager_type_id;
		user_settings_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "UserSettingsManager", &g_define_type_info, 0);
		g_once_init_leave (&user_settings_manager_type_id__volatile, user_settings_manager_type_id);
	}
	return user_settings_manager_type_id__volatile;
}



