/* NoteEditor.c generated by valac 0.14.2, the Vala compiler
 * generated from NoteEditor.vala, do not modify */

/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* PSNotes
 *
 * Copyright (C) Zach Burnham 2012 <thejambi@gmail.com>
 *
PSNotes is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * PSNotes is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_NOTE_EDITOR (note_editor_get_type ())
#define NOTE_EDITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NOTE_EDITOR, NoteEditor))
#define NOTE_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NOTE_EDITOR, NoteEditorClass))
#define IS_NOTE_EDITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NOTE_EDITOR))
#define IS_NOTE_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NOTE_EDITOR))
#define NOTE_EDITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NOTE_EDITOR, NoteEditorClass))

typedef struct _NoteEditor NoteEditor;
typedef struct _NoteEditorClass NoteEditorClass;
typedef struct _NoteEditorPrivate NoteEditorPrivate;

#define TYPE_ACTION (action_get_type ())
#define ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ACTION, Action))
#define ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ACTION, ActionClass))
#define IS_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ACTION))
#define IS_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ACTION))
#define ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ACTION, ActionClass))

typedef struct _Action Action;
typedef struct _ActionClass ActionClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _action_unref0(var) ((var == NULL) ? NULL : (var = (action_unref (var), NULL)))
typedef struct _ActionPrivate ActionPrivate;
typedef struct _ParamSpecAction ParamSpecAction;

struct _NoteEditor {
	GObject parent_instance;
	NoteEditorPrivate * priv;
};

struct _NoteEditorClass {
	GObjectClass parent_class;
};

struct _NoteEditorPrivate {
	GtkTextBuffer* buffer;
	gint undoMax;
	GeeArrayList* undos;
	GeeArrayList* redos;
	gulong onInsertConnection;
	gulong onDeleteConnection;
};

struct _Action {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ActionPrivate * priv;
};

struct _ActionClass {
	GTypeClass parent_class;
	void (*finalize) (Action *self);
};

struct _ActionPrivate {
	gchar* _action;
	gchar* _text;
	gint _offset;
};

struct _ParamSpecAction {
	GParamSpec parent_instance;
};


static gpointer note_editor_parent_class = NULL;
static gpointer action_parent_class = NULL;

GType note_editor_get_type (void) G_GNUC_CONST;
gpointer action_ref (gpointer instance);
void action_unref (gpointer instance);
GParamSpec* param_spec_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_action (GValue* value, gpointer v_object);
void value_take_action (GValue* value, gpointer v_object);
gpointer value_get_action (const GValue* value);
GType action_get_type (void) G_GNUC_CONST;
#define NOTE_EDITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_NOTE_EDITOR, NoteEditorPrivate))
enum  {
	NOTE_EDITOR_DUMMY_PROPERTY
};
NoteEditor* note_editor_new (GtkTextBuffer* buffer);
NoteEditor* note_editor_construct (GType object_type, GtkTextBuffer* buffer);
static void note_editor_connectSignals (NoteEditor* self);
static void note_editor_getStartIter (NoteEditor* self, GtkTextIter* result);
static void note_editor_getEndIter (NoteEditor* self, GtkTextIter* result);
gchar* note_editor_getText (NoteEditor* self);
gchar* note_editor_firstLine (NoteEditor* self);
gint note_editor_lineCount (NoteEditor* self);
void note_editor_startNewNote (NoteEditor* self, const gchar* text);
static void note_editor_disconnectSignals (NoteEditor* self);
static void note_editor_getIterAtOffset (NoteEditor* self, gint offset, GtkTextIter* result);
void note_editor_append (NoteEditor* self, const gchar* text);
void note_editor_prepend (NoteEditor* self, const gchar* text);
void note_editor_prependDateToEntry (NoteEditor* self, const gchar* dateHeading);
void note_editor_insertAtCursor (NoteEditor* self, const gchar* text);
static void note_editor_getCurrentIter (NoteEditor* self, GtkTextIter* result);
void note_editor_cursorToEnd (NoteEditor* self);
void note_editor_cursorToStart (NoteEditor* self);
void note_editor_undo (NoteEditor* self);
void zystem_debug (const gchar* s);
Action* note_editor_doAction (NoteEditor* self, Action* action);
const gchar* action_get_action (Action* self);
gint action_get_offset (Action* self);
const gchar* action_get_text (Action* self);
void action_set_action (Action* self, const gchar* value);
void note_editor_redo (NoteEditor* self);
static void note_editor_onInsertText (NoteEditor* self, GtkTextIter* iter, const gchar* text, gint length);
Action* action_new (const gchar* action, gint offset, const gchar* text);
Action* action_construct (GType object_type, const gchar* action, gint offset, const gchar* text);
static void note_editor_onDeleteRange (NoteEditor* self, GtkTextIter* startIter, GtkTextIter* endIter);
static void note_editor_addUndo (NoteEditor* self, Action* cmd);
static void __lambda0_ (NoteEditor* self, GtkTextIter* iter, const gchar* text, gint length);
static void ___lambda0__gtk_text_buffer_insert_text (GtkTextBuffer* _sender, GtkTextIter* pos, const gchar* new_text, gint new_text_length, gpointer self);
static void __lambda1_ (NoteEditor* self, GtkTextIter* startIter, GtkTextIter* endIter);
static void ___lambda1__gtk_text_buffer_delete_range (GtkTextBuffer* _sender, GtkTextIter* start, GtkTextIter* end, gpointer self);
static void note_editor_finalize (GObject* obj);
#define ACTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_ACTION, ActionPrivate))
enum  {
	ACTION_DUMMY_PROPERTY
};
void action_set_text (Action* self, const gchar* value);
void action_set_offset (Action* self, gint value);
static void action_finalize (Action* obj);


/**
 * Constructor for NoteEditor.
 */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


NoteEditor* note_editor_construct (GType object_type, GtkTextBuffer* buffer) {
	NoteEditor * self = NULL;
	GtkTextBuffer* _tmp0_;
	GtkTextBuffer* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	g_return_val_if_fail (buffer != NULL, NULL);
	self = (NoteEditor*) g_object_new (object_type, NULL);
	_tmp0_ = buffer;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->buffer);
	self->priv->buffer = _tmp1_;
	self->priv->undoMax = 1000;
	_tmp2_ = gee_array_list_new (TYPE_ACTION, (GBoxedCopyFunc) action_ref, action_unref, NULL);
	_g_object_unref0 (self->priv->undos);
	self->priv->undos = _tmp2_;
	_tmp3_ = gee_array_list_new (TYPE_ACTION, (GBoxedCopyFunc) action_ref, action_unref, NULL);
	_g_object_unref0 (self->priv->redos);
	self->priv->redos = _tmp3_;
	note_editor_connectSignals (self);
	return self;
}


NoteEditor* note_editor_new (GtkTextBuffer* buffer) {
	return note_editor_construct (TYPE_NOTE_EDITOR, buffer);
}


static void note_editor_getStartIter (NoteEditor* self, GtkTextIter* result) {
	GtkTextIter startIter = {0};
	GtkTextBuffer* _tmp0_;
	GtkTextIter _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->buffer;
	gtk_text_buffer_get_start_iter (_tmp0_, &_tmp1_);
	startIter = _tmp1_;
	*result = startIter;
	return;
}


static void note_editor_getEndIter (NoteEditor* self, GtkTextIter* result) {
	GtkTextIter endIter = {0};
	GtkTextBuffer* _tmp0_;
	GtkTextIter _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->buffer;
	gtk_text_buffer_get_end_iter (_tmp0_, &_tmp1_);
	endIter = _tmp1_;
	*result = endIter;
	return;
}


gchar* note_editor_getText (NoteEditor* self) {
	gchar* result = NULL;
	GtkTextBuffer* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->buffer;
	g_object_get (_tmp0_, "text", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


gchar* note_editor_firstLine (NoteEditor* self) {
	gchar* result = NULL;
	GtkTextIter startIter = {0};
	GtkTextBuffer* _tmp0_;
	GtkTextIter _tmp1_ = {0};
	gint _tmp2_ = 0;
	GtkTextIter endIter = {0};
	GtkTextBuffer* _tmp7_;
	GtkTextIter _tmp8_ = {0};
	GtkTextBuffer* _tmp9_;
	GtkTextIter _tmp10_;
	GtkTextIter _tmp11_;
	gchar* _tmp12_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->buffer;
	gtk_text_buffer_get_iter_at_line (_tmp0_, &_tmp1_, 0);
	startIter = _tmp1_;
	_tmp2_ = note_editor_lineCount (self);
	if (_tmp2_ == 1) {
		GtkTextBuffer* _tmp3_;
		GtkTextIter _tmp4_;
		GtkTextIter _tmp5_ = {0};
		gchar* _tmp6_ = NULL;
		_tmp3_ = self->priv->buffer;
		_tmp4_ = startIter;
		note_editor_getEndIter (self, &_tmp5_);
		_tmp6_ = gtk_text_buffer_get_text (_tmp3_, &_tmp4_, &_tmp5_, FALSE);
		result = _tmp6_;
		return result;
	}
	_tmp7_ = self->priv->buffer;
	gtk_text_buffer_get_iter_at_line (_tmp7_, &_tmp8_, 1);
	endIter = _tmp8_;
	_tmp9_ = self->priv->buffer;
	_tmp10_ = startIter;
	_tmp11_ = endIter;
	_tmp12_ = gtk_text_buffer_get_text (_tmp9_, &_tmp10_, &_tmp11_, FALSE);
	result = _tmp12_;
	return result;
}


gint note_editor_lineCount (NoteEditor* self) {
	gint result = 0;
	GtkTextBuffer* _tmp0_;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->buffer;
	_tmp1_ = gtk_text_buffer_get_line_count (_tmp0_);
	result = _tmp1_;
	return result;
}


void note_editor_startNewNote (NoteEditor* self, const gchar* text) {
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	GtkTextBuffer* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = self->priv->undos;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
	_tmp1_ = self->priv->redos;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp1_);
	note_editor_disconnectSignals (self);
	_tmp2_ = self->priv->buffer;
	_tmp3_ = text;
	gtk_text_buffer_set_text (_tmp2_, _tmp3_, -1);
	note_editor_connectSignals (self);
}


static void note_editor_getIterAtOffset (NoteEditor* self, gint offset, GtkTextIter* result) {
	GtkTextIter iter = {0};
	GtkTextBuffer* _tmp0_;
	gint _tmp1_;
	GtkTextIter _tmp2_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->buffer;
	_tmp1_ = offset;
	gtk_text_buffer_get_iter_at_offset (_tmp0_, &_tmp2_, _tmp1_);
	iter = _tmp2_;
	*result = iter;
	return;
}


void note_editor_append (NoteEditor* self, const gchar* text) {
	GtkTextBuffer* _tmp0_;
	GtkTextIter _tmp1_ = {0};
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = self->priv->buffer;
	note_editor_getEndIter (self, &_tmp1_);
	_tmp2_ = text;
	_tmp3_ = text;
	_tmp4_ = strlen (_tmp3_);
	_tmp5_ = _tmp4_;
	gtk_text_buffer_insert (_tmp0_, &_tmp1_, _tmp2_, _tmp5_);
}


void note_editor_prepend (NoteEditor* self, const gchar* text) {
	GtkTextIter _tmp0_ = {0};
	GtkTextIter startIter;
	GtkTextBuffer* _tmp1_;
	GtkTextIter _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	note_editor_getStartIter (self, &_tmp0_);
	startIter = _tmp0_;
	_tmp1_ = self->priv->buffer;
	_tmp2_ = startIter;
	_tmp3_ = text;
	_tmp4_ = text;
	_tmp5_ = strlen (_tmp4_);
	_tmp6_ = _tmp5_;
	gtk_text_buffer_insert (_tmp1_, &_tmp2_, _tmp3_, _tmp6_);
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


void note_editor_prependDateToEntry (NoteEditor* self, const gchar* dateHeading) {
	GtkTextBuffer* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dateHeading != NULL);
	_tmp0_ = self->priv->buffer;
	g_object_get (_tmp0_, "text", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp4_ = dateHeading;
	_tmp5_ = string_strip (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_str_has_prefix (_tmp3_, _tmp6_);
	_tmp8_ = !_tmp7_;
	_g_free0 (_tmp6_);
	_g_free0 (_tmp3_);
	if (_tmp8_) {
		const gchar* _tmp9_;
		_tmp9_ = dateHeading;
		note_editor_prepend (self, _tmp9_);
	}
}


void note_editor_insertAtCursor (NoteEditor* self, const gchar* text) {
	GtkTextIter _tmp0_ = {0};
	GtkTextIter startIter;
	GtkTextBuffer* _tmp1_;
	GtkTextIter _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	note_editor_getCurrentIter (self, &_tmp0_);
	startIter = _tmp0_;
	_tmp1_ = self->priv->buffer;
	_tmp2_ = startIter;
	_tmp3_ = text;
	_tmp4_ = text;
	_tmp5_ = strlen (_tmp4_);
	_tmp6_ = _tmp5_;
	gtk_text_buffer_insert (_tmp1_, &_tmp2_, _tmp3_, _tmp6_);
}


void note_editor_cursorToEnd (NoteEditor* self) {
	GtkTextBuffer* _tmp0_;
	GtkTextIter _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->buffer;
	note_editor_getEndIter (self, &_tmp1_);
	gtk_text_buffer_place_cursor (_tmp0_, &_tmp1_);
}


void note_editor_cursorToStart (NoteEditor* self) {
	GtkTextBuffer* _tmp0_;
	GtkTextIter _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->buffer;
	note_editor_getStartIter (self, &_tmp1_);
	gtk_text_buffer_place_cursor (_tmp0_, &_tmp1_);
}


static void note_editor_getCurrentIter (NoteEditor* self, GtkTextIter* result) {
	GtkTextIter iter = {0};
	GtkTextBuffer* _tmp0_;
	GtkTextBuffer* _tmp1_;
	gint _tmp2_ = 0;
	gint _tmp3_;
	GtkTextIter _tmp4_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->buffer;
	_tmp1_ = self->priv->buffer;
	g_object_get (_tmp1_, "cursor-position", &_tmp2_, NULL);
	_tmp3_ = _tmp2_;
	gtk_text_buffer_get_iter_at_offset (_tmp0_, &_tmp4_, _tmp3_);
	iter = _tmp4_;
	*result = iter;
	return;
}


void note_editor_undo (NoteEditor* self) {
	GeeArrayList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	GeeArrayList* _tmp3_;
	gpointer _tmp4_ = NULL;
	Action* undo;
	Action* _tmp5_;
	Action* _tmp6_ = NULL;
	Action* redo;
	GeeArrayList* _tmp7_;
	Action* _tmp8_;
	GeeArrayList* _tmp9_;
	Action* _tmp10_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->undos;
	_tmp1_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 0) {
		zystem_debug ("Nothing to undo");
		return;
	}
	note_editor_disconnectSignals (self);
	_tmp3_ = self->priv->undos;
	_tmp4_ = gee_abstract_list_last ((GeeAbstractList*) _tmp3_);
	undo = (Action*) _tmp4_;
	_tmp5_ = undo;
	_tmp6_ = note_editor_doAction (self, _tmp5_);
	redo = _tmp6_;
	_tmp7_ = self->priv->redos;
	_tmp8_ = redo;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp7_, _tmp8_);
	_tmp9_ = self->priv->undos;
	_tmp10_ = undo;
	gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp9_, _tmp10_);
	note_editor_connectSignals (self);
	_action_unref0 (redo);
	_action_unref0 (undo);
}


static gpointer _action_ref0 (gpointer self) {
	return self ? action_ref (self) : NULL;
}


Action* note_editor_doAction (NoteEditor* self, Action* action) {
	Action* result = NULL;
	Action* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	Action* _tmp47_;
	Action* _tmp48_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (action != NULL, NULL);
	_tmp0_ = action;
	_tmp1_ = action_get_action (_tmp0_);
	_tmp2_ = _tmp1_;
	if (g_strcmp0 (_tmp2_, "delete") == 0) {
		Action* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		GtkTextIter _tmp6_ = {0};
		GtkTextIter start;
		Action* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		Action* _tmp10_;
		const gchar* _tmp11_;
		const gchar* _tmp12_;
		gint _tmp13_;
		gint _tmp14_;
		GtkTextIter _tmp15_ = {0};
		GtkTextIter end;
		GtkTextBuffer* _tmp16_;
		GtkTextIter _tmp17_;
		GtkTextIter _tmp18_;
		Action* _tmp19_;
		_tmp3_ = action;
		_tmp4_ = action_get_offset (_tmp3_);
		_tmp5_ = _tmp4_;
		note_editor_getIterAtOffset (self, _tmp5_, &_tmp6_);
		start = _tmp6_;
		_tmp7_ = action;
		_tmp8_ = action_get_offset (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = action;
		_tmp11_ = action_get_text (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = strlen (_tmp12_);
		_tmp14_ = _tmp13_;
		note_editor_getIterAtOffset (self, _tmp9_ + _tmp14_, &_tmp15_);
		end = _tmp15_;
		_tmp16_ = self->priv->buffer;
		_tmp17_ = start;
		_tmp18_ = end;
		gtk_text_buffer_delete (_tmp16_, &_tmp17_, &_tmp18_);
		_tmp19_ = action;
		action_set_action (_tmp19_, "insert");
	} else {
		Action* _tmp20_;
		const gchar* _tmp21_;
		const gchar* _tmp22_;
		_tmp20_ = action;
		_tmp21_ = action_get_action (_tmp20_);
		_tmp22_ = _tmp21_;
		if (g_strcmp0 (_tmp22_, "insert") == 0) {
			Action* _tmp23_;
			gint _tmp24_;
			gint _tmp25_;
			GtkTextIter _tmp26_ = {0};
			GtkTextIter start;
			Action* _tmp27_;
			gint _tmp28_;
			gint _tmp29_;
			Action* _tmp30_;
			const gchar* _tmp31_;
			const gchar* _tmp32_;
			gint _tmp33_;
			gint _tmp34_;
			GtkTextIter _tmp35_ = {0};
			GtkTextIter end;
			GtkTextBuffer* _tmp36_;
			GtkTextIter _tmp37_;
			Action* _tmp38_;
			const gchar* _tmp39_;
			const gchar* _tmp40_;
			Action* _tmp41_;
			const gchar* _tmp42_;
			const gchar* _tmp43_;
			gint _tmp44_;
			gint _tmp45_;
			Action* _tmp46_;
			_tmp23_ = action;
			_tmp24_ = action_get_offset (_tmp23_);
			_tmp25_ = _tmp24_;
			note_editor_getIterAtOffset (self, _tmp25_, &_tmp26_);
			start = _tmp26_;
			_tmp27_ = action;
			_tmp28_ = action_get_offset (_tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = action;
			_tmp31_ = action_get_text (_tmp30_);
			_tmp32_ = _tmp31_;
			_tmp33_ = strlen (_tmp32_);
			_tmp34_ = _tmp33_;
			note_editor_getIterAtOffset (self, _tmp29_ + _tmp34_, &_tmp35_);
			end = _tmp35_;
			_tmp36_ = self->priv->buffer;
			_tmp37_ = start;
			_tmp38_ = action;
			_tmp39_ = action_get_text (_tmp38_);
			_tmp40_ = _tmp39_;
			_tmp41_ = action;
			_tmp42_ = action_get_text (_tmp41_);
			_tmp43_ = _tmp42_;
			_tmp44_ = strlen (_tmp43_);
			_tmp45_ = _tmp44_;
			gtk_text_buffer_insert (_tmp36_, &_tmp37_, _tmp40_, _tmp45_);
			_tmp46_ = action;
			action_set_action (_tmp46_, "delete");
		}
	}
	_tmp47_ = action;
	_tmp48_ = _action_ref0 (_tmp47_);
	result = _tmp48_;
	return result;
}


void note_editor_redo (NoteEditor* self) {
	GeeArrayList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	GeeArrayList* _tmp3_;
	gpointer _tmp4_ = NULL;
	Action* redo;
	Action* _tmp5_;
	Action* _tmp6_ = NULL;
	Action* undo;
	GeeArrayList* _tmp7_;
	Action* _tmp8_;
	GeeArrayList* _tmp9_;
	Action* _tmp10_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->redos;
	_tmp1_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 0) {
		zystem_debug ("Nothing to redo");
		return;
	}
	note_editor_disconnectSignals (self);
	_tmp3_ = self->priv->redos;
	_tmp4_ = gee_abstract_list_last ((GeeAbstractList*) _tmp3_);
	redo = (Action*) _tmp4_;
	_tmp5_ = redo;
	_tmp6_ = note_editor_doAction (self, _tmp5_);
	undo = _tmp6_;
	_tmp7_ = self->priv->undos;
	_tmp8_ = undo;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp7_, _tmp8_);
	_tmp9_ = self->priv->redos;
	_tmp10_ = redo;
	gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp9_, _tmp10_);
	note_editor_connectSignals (self);
	_action_unref0 (undo);
	_action_unref0 (redo);
}


static void note_editor_onInsertText (NoteEditor* self, GtkTextIter* iter, const gchar* text, gint length) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gint _tmp3_ = 0;
	const gchar* _tmp4_;
	Action* _tmp5_;
	Action* cmd;
	GeeArrayList* _tmp6_;
	GeeArrayList* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (iter != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = text;
	_tmp1_ = g_strconcat ("HEY THERE IT'S THE ONINSERTTEXT SPEAKING HERE: ", _tmp0_, NULL);
	_tmp2_ = _tmp1_;
	zystem_debug (_tmp2_);
	_g_free0 (_tmp2_);
	_tmp3_ = gtk_text_iter_get_offset (iter);
	_tmp4_ = text;
	_tmp5_ = action_new ("delete", _tmp3_, _tmp4_);
	cmd = _tmp5_;
	_tmp6_ = self->priv->undos;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, cmd);
	_tmp7_ = self->priv->redos;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp7_);
	_action_unref0 (cmd);
}


static void note_editor_onDeleteRange (NoteEditor* self, GtkTextIter* startIter, GtkTextIter* endIter) {
	GtkTextBuffer* _tmp0_;
	GtkTextIter _tmp1_;
	GtkTextIter _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* text;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gint _tmp6_ = 0;
	Action* _tmp7_;
	Action* cmd;
	g_return_if_fail (self != NULL);
	g_return_if_fail (startIter != NULL);
	g_return_if_fail (endIter != NULL);
	zystem_debug ("In onDeleteRange()");
	_tmp0_ = self->priv->buffer;
	_tmp1_ = *startIter;
	_tmp2_ = *endIter;
	_tmp3_ = gtk_text_buffer_get_text (_tmp0_, &_tmp1_, &_tmp2_, FALSE);
	text = _tmp3_;
	_tmp4_ = g_strconcat ("Text was: ", text, NULL);
	_tmp5_ = _tmp4_;
	zystem_debug (_tmp5_);
	_g_free0 (_tmp5_);
	_tmp6_ = gtk_text_iter_get_offset (startIter);
	_tmp7_ = action_new ("insert", _tmp6_, text);
	cmd = _tmp7_;
	note_editor_addUndo (self, cmd);
	_action_unref0 (cmd);
	_g_free0 (text);
}


static void note_editor_addUndo (NoteEditor* self, Action* cmd) {
	GeeArrayList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	GeeArrayList* _tmp4_;
	Action* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cmd != NULL);
	_tmp0_ = self->priv->undos;
	_tmp1_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->undoMax;
	if (_tmp2_ >= _tmp3_) {
	}
	_tmp4_ = self->priv->undos;
	_tmp5_ = cmd;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, _tmp5_);
}


static void __lambda0_ (NoteEditor* self, GtkTextIter* iter, const gchar* text, gint length) {
	GtkTextIter _tmp0_;
	const gchar* _tmp1_;
	gint _tmp2_;
	g_return_if_fail (iter != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = *iter;
	_tmp1_ = text;
	_tmp2_ = length;
	note_editor_onInsertText (self, &_tmp0_, _tmp1_, _tmp2_);
}


static void ___lambda0__gtk_text_buffer_insert_text (GtkTextBuffer* _sender, GtkTextIter* pos, const gchar* new_text, gint new_text_length, gpointer self) {
	__lambda0_ (self, pos, new_text, new_text_length);
}


static void __lambda1_ (NoteEditor* self, GtkTextIter* startIter, GtkTextIter* endIter) {
	GtkTextIter _tmp0_;
	GtkTextIter _tmp1_;
	g_return_if_fail (startIter != NULL);
	g_return_if_fail (endIter != NULL);
	_tmp0_ = *startIter;
	_tmp1_ = *endIter;
	note_editor_onDeleteRange (self, &_tmp0_, &_tmp1_);
}


static void ___lambda1__gtk_text_buffer_delete_range (GtkTextBuffer* _sender, GtkTextIter* start, GtkTextIter* end, gpointer self) {
	__lambda1_ (self, start, end);
}


static void note_editor_connectSignals (NoteEditor* self) {
	GtkTextBuffer* _tmp0_;
	gulong _tmp1_ = 0UL;
	GtkTextBuffer* _tmp2_;
	gulong _tmp3_ = 0UL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->buffer;
	_tmp1_ = g_signal_connect_object (_tmp0_, "insert-text", (GCallback) ___lambda0__gtk_text_buffer_insert_text, self, 0);
	self->priv->onInsertConnection = _tmp1_;
	_tmp2_ = self->priv->buffer;
	_tmp3_ = g_signal_connect_object (_tmp2_, "delete-range", (GCallback) ___lambda1__gtk_text_buffer_delete_range, self, 0);
	self->priv->onDeleteConnection = _tmp3_;
}


static void note_editor_disconnectSignals (NoteEditor* self) {
	GtkTextBuffer* _tmp0_;
	gulong _tmp1_;
	GtkTextBuffer* _tmp2_;
	gulong _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->buffer;
	_tmp1_ = self->priv->onInsertConnection;
	g_signal_handler_disconnect ((GObject*) _tmp0_, _tmp1_);
	_tmp2_ = self->priv->buffer;
	_tmp3_ = self->priv->onDeleteConnection;
	g_signal_handler_disconnect ((GObject*) _tmp2_, _tmp3_);
}


static void note_editor_class_init (NoteEditorClass * klass) {
	note_editor_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (NoteEditorPrivate));
	G_OBJECT_CLASS (klass)->finalize = note_editor_finalize;
}


static void note_editor_instance_init (NoteEditor * self) {
	self->priv = NOTE_EDITOR_GET_PRIVATE (self);
}


static void note_editor_finalize (GObject* obj) {
	NoteEditor * self;
	self = NOTE_EDITOR (obj);
	_g_object_unref0 (self->priv->buffer);
	_g_object_unref0 (self->priv->undos);
	_g_object_unref0 (self->priv->redos);
	G_OBJECT_CLASS (note_editor_parent_class)->finalize (obj);
}


GType note_editor_get_type (void) {
	static volatile gsize note_editor_type_id__volatile = 0;
	if (g_once_init_enter (&note_editor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NoteEditorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) note_editor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NoteEditor), 0, (GInstanceInitFunc) note_editor_instance_init, NULL };
		GType note_editor_type_id;
		note_editor_type_id = g_type_register_static (G_TYPE_OBJECT, "NoteEditor", &g_define_type_info, 0);
		g_once_init_leave (&note_editor_type_id__volatile, note_editor_type_id);
	}
	return note_editor_type_id__volatile;
}


Action* action_construct (GType object_type, const gchar* action, gint offset, const gchar* text) {
	Action* self = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (action != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	self = (Action*) g_type_create_instance (object_type);
	_tmp0_ = action;
	action_set_action (self, _tmp0_);
	_tmp1_ = text;
	action_set_text (self, _tmp1_);
	_tmp2_ = offset;
	action_set_offset (self, _tmp2_);
	return self;
}


Action* action_new (const gchar* action, gint offset, const gchar* text) {
	return action_construct (TYPE_ACTION, action, offset, text);
}


const gchar* action_get_action (Action* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_action;
	result = _tmp0_;
	return result;
}


void action_set_action (Action* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_action);
	self->priv->_action = _tmp1_;
}


const gchar* action_get_text (Action* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_text;
	result = _tmp0_;
	return result;
}


void action_set_text (Action* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_text);
	self->priv->_text = _tmp1_;
}


gint action_get_offset (Action* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_offset;
	result = _tmp0_;
	return result;
}


void action_set_offset (Action* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_offset = _tmp0_;
}


static void value_action_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_action_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		action_unref (value->data[0].v_pointer);
	}
}


static void value_action_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = action_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_action_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_action_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Action* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = action_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_action_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Action** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = action_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecAction* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_ACTION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_action (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_ACTION), NULL);
	return value->data[0].v_pointer;
}


void value_set_action (GValue* value, gpointer v_object) {
	Action* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_ACTION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_ACTION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		action_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		action_unref (old);
	}
}


void value_take_action (GValue* value, gpointer v_object) {
	Action* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_ACTION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_ACTION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		action_unref (old);
	}
}


static void action_class_init (ActionClass * klass) {
	action_parent_class = g_type_class_peek_parent (klass);
	ACTION_CLASS (klass)->finalize = action_finalize;
	g_type_class_add_private (klass, sizeof (ActionPrivate));
}


static void action_instance_init (Action * self) {
	self->priv = ACTION_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void action_finalize (Action* obj) {
	Action * self;
	self = ACTION (obj);
	_g_free0 (self->priv->_action);
	_g_free0 (self->priv->_text);
}


GType action_get_type (void) {
	static volatile gsize action_type_id__volatile = 0;
	if (g_once_init_enter (&action_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_action_init, value_action_free_value, value_action_copy_value, value_action_peek_pointer, "p", value_action_collect_value, "p", value_action_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ActionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) action_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Action), 0, (GInstanceInitFunc) action_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType action_type_id;
		action_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Action", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&action_type_id__volatile, action_type_id);
	}
	return action_type_id__volatile;
}


gpointer action_ref (gpointer instance) {
	Action* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void action_unref (gpointer instance) {
	Action* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ACTION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



